##컴퓨터는 비트를 어떻게 기억하는가 p.135
조합 논리는 입력에 의해서만 출력이 기억된다. 하지만 조합 논리만으로는 컴퓨터를 만들 수는 없다. 흐름의 일부분을 뗴어내서 해둘려면 순차 논리(sequential logic)이 필요하다. 사람들은 시간의 흐름을 직관적으로 알지만 컴퓨터는 아니다. 디지털 회로에서 시간을 어떻게든 만들어야 한다. 순차 논리는 입력의 현재 상태와 과거 상태를 함께 고려하기 때문에 가능하다.

### 시간 표현과 상태 기억 p.136
1. 우린 주기(periodic) 함수를 사용해 시간을 측정할 수 있다. 주기적 함수는 지구의 자전, 지구가 한 바퀴를 다 돌면 하루라고 부르는 것 등이다. 컴퓨터의 경우 전자공학을 사용하기 때문에 주기적인 전기 신호가 필요하다.
   <br/><br/>
2. 되먹임(feedback)은 인버터의 출력을 입력에 연결하는 것이다. 이렇게 하면 0과 1 사이를 진동한다(oscillate). 진동하는 속도는 전파 지연에 따라 결정되고 온도에 따라 달라진다. 좀 더 안정적인 주파수로 진동하는 발진자(oscillator)가 필요하다.
   <br/><br/>
3. 전극(electrode,전선)을 크리스털(crystal)을 연결하고 압축하면 전기를 만들어낸다. 그리고 전극에 전기를 가하면 크리스털이 구부러진다. 이런 현상을 피에조 전기(piezoelectric, 압전) 효과라 부른다. 이 효과는 음성 진동을 잡아낼 수 있어서 마이크를 만들 때 쓸 수 있다.
   <br/><br/>
4. 크리스털 발진자는 전자적인 단극쌍투 스위치를 사용해 크리스털에 전기를 가해서 다시 전기를 얻어낸다. 입력한 전기로부터 크리스털이 전기를 다시 만들어내는 시간은 예측이 가능하며 매우 정확하다.
   <br/><br/>
5. 발진자는 클록(clock, 시간을 셀 수 있게 해주는 신호)을 제공한다. 클록을 활용하면 전파 지연 처럼 결과가 최악의 겨우를 가정해 가산기의 지연 시간을 기다릴 수 있다. 클록은 회로의 페이스(pace)를 결정한다. 회로의 최대 클록 속도나 가장 빠른 템포(tempo)는 회로의 전파 지연 시간에 의해 결정된다.
   <br/><br/>
6. 래치(latch)는 OR 게이트의 출력을 입력에 묶는 방식의 되먹임을 사용하여 1비트의 정보를 기억할 수 있다. set, reset, out을 활용하여 과거와 현재를 기억할 수 있다.
   <br/><br/>
7. 플립플롭(flip-flop)은 데이터 변경으로 인해 잘못된 결과가 생길 수 있는 가능성을 최소화 했다. 논리 수준이 특정 값에 머무는 동안 데이터를 잡아내지 않고 논리 수준이 한 수준에서 다른 수준으로 전이되는 중간에 데이터를 잡아 내는 것이다.
   <br/><br/>
8. 카운터(counter)는 플립플롭을 응용하여 1, 2, 3 순서대로 수를 세는 회로다.
   <br/><br/>
9. 레지스터(register)는 클록을 공유하는 여러 D 플립플롭을 한 패키지에 넣은 것이다. 가산기 회로로 덧셈한 결과를 레지스터에 저장할 수도 있다.

### 메모리 조직과 주소 지정 p.148
1. 비트를 하나 기억할 때 플립플롭이 유용하고 레지스터를 사용하면 여러 비트를 쉽게 저장할 수 있다. 더 많은 정보를 저장해야한다면 어떻게 해야 할까. 각 레지스터에 번호를 부여하는 방법을 사용하는 것이다. 그리고 셀렉터를 통해 특정 주소의 레지스터를 출력할 수 있다.
   <br/><br/>
2. 여러 메모리 컴포넌트의 출력을 한 출력으로 연결해야 할 수도 있는데, 이런 경우 트라이스테이트(tri-state) 출력이라는 또 다른 기본 요소가 쓰인다. 메모리 컴포넌트는 연결 지점이 아주 많다. 32비트면 입력과 출력을 32개씩 연결해야 하고 주소, 제어 신호, 전원도 연결해야 한다. 메모리를 동시에 읽고 쓸 필요가 있는 경우는 거의 없다는 사실을 통해 read/write 제어 신호를 사용해 연결을 많이 줄였다. enable 제어 신호를 통해 메모리 전체를 켜거나 꺼서 여러 메모리 칩을 함께 연결할 수 있게 되었다.
   <br/><br/>
3. 주소와 데이터에는 대량 교통 수단이 필요하다. 이런 연관된 신호를 버스라 부르고 메모리 칩에는 주소 버스와 데이터 버스가 있다. 버스는 비트는 이동시키는 대량 교통 수단인 셈이다.
   <br/><br/>
4. RAM(Random Access Memory)는 메모리 위치 중 원하는 곳은 어디든 순서로 쓰거나 읽을 수 있다. SRAM과 DRAM이 있다. SRAM과 DRAM은 모두 휘발성(Volatile)이다.
   <br/><br/>
5. ROM(Read Only Memoery)는 이름과는 다르게 한 번만 쓸 수 있는 메모리(write-once memory)라고도 불릴 수 있다. ROM은 한번 쓰고 나면 여러번 읽을 수 있다. 전자레인지 같이 프로그램을 내장해야 하는 장치에 ROM이 유용하다. P(Programmable)ROM은 직접 프로그래밍 할 수 있는 ROM이지만 수정할 수 없었다. 그래서 EEP(Electrically Erasable Programmable)ROM가 만들어졌다. EEPROM은 전기로 내용을 지울 수 있다.

### 블록 장치 p.156
1. 디스크 드라이브(Disk Drive)는 엄청나게 많은 데이터를 저장할 수 있지만 메모리보다 상대적으로 느리다.
   <br/><br/>
2. 디스크는 바이트 단위로 주소를 지정해 읽는 대신 블록(또는 섹터) 단위로 주소를 지정해 읽는다. 디스크는 원판(Platter)가 하나 이상의 회전축에 연결되어 돌아간다.
   <br/><br/>
3. 현대적인 디스크는 방사상으로 움직이는 엑추에이터 암(actuator arm)에 달린 디스크 헤드(Disk Head)가 트랙을 돌며 탐색한다. 이때, 트랙과 트랙을 이동하는 시간을 탐색 시간(seek time)이라 한다.

### 플래시 메모리와 SSD p.159
1. 플래시 메모리(Flash Memory)는 EEPROM이다. 플래시 메모리는 전체를 지우지 않고 원하는 비트만 0으로 되돌리기 위해 블록으로 나눴다. 그래서 플래시 메모리는 쓸 때는 블록 접근(block access)장치 이고 읽을 때는 임의 접근(random access) 장치다.
   <br/><br/>
2. SSD(고체 상태 드라이브,solid-state drive)는 디스크 드라이브 모양의 패키지에 넣은 플래시 메모리와 같다. 여러 블록의 쓴 횟수를 기억해서 모든 블록이 가능하면 똑같은 수준으로 낡도록 조정(wear leveling)하는 프로세서가 들어 있다.

### 오류 감지와 정정 p.159
1. 메모리에 무언가 닿아 비트가 잘못되었다면 알 방법이 필요하다. 하지만 이 방법들은 비싸기 때문에 일반적인 컴퓨터에는 쓰이지 않는다.
   <br/><br/>
2. 패리티(parity)사용한 검사 방법은 1로 설정된 비트의 개수가 짝수인지 홀수인지 나타내는 1비트를 데이터에 덧붙이는 방식이다. 모든 비트의 XOR을 취하면 쉽게 이런 비트를 만들 수 있다. 짝수 패리티(even parity)는 모든 비트를 서로 XOR한 값을 사용하며, 홀수 패리티(odd parity)는 XOR한 값의 보수를 사용한다. 하지만 패리티 검사방식은 문제점은 오류가 짝수번 날 경우 오류가 발생하지 않은 경우와 구분할 방법이 없다.
   <br/><br/>
3. 더 복잡한 방식으로는 더 많은 비트를 사용해 더 많은 오류를 감지할 수 있는 해밍 코드(Hamming code)가 있다. 데이터의 각 지점(예: 바이트)을 n 비트값으로 더하고, n비트를 넘어가는 값을 무시하는 체크섬(checksum)방법도 있다. 순환 중복 검사(CRC, cyclic redundancy check)는 수학적으로 체크섬보다 더 나은 대체재다. 해시 코드도 도 다른 더 나은 대체재다.
   <br/><br/>
4. 결국 이런 방식의 목표는 데이터의 고유성을 추분히 드러낼 수 있는 방식으로 검증 숫자를 계산해서, 데이터가 약간이라도 바뀌면 검증 숫자가 더 이상 일치하지 않게 만드는 것이다.