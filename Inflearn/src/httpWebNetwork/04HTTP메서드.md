# HTTP API를 만들어보자.
1. 요구사항 -> 회원 정보 관리 API를 만들어라. -> 회원 목록 조회, 회원 조회, 회원 등록, 회원 수정, 회원 삭제

### API URI 설계
1. 회원 목록 조회(/read-member-list), 회원 조회(/read-member-by-id) 등 -> 이것은 좋은 URI 설계일까? -> 가장 중요한 것은 리소스 식별 
2. 리소스의 의미는 회원을 등록하고 수정하고 조회하는게 리소스가 아니다. -> 회원이라는 개념 자체가 바로 리소스다.
3. 리소스를 식별하기 위해서 회원을 등록하고 수정하고 조회하는 것을 모두 배제한다. -> 회원이라는 리소스만 식별하면 된다. -> 회원 리소스를 URI에 매핑
4. 회원 목록 조회(/members), 회원 조회(/members/{id}), 회원 등록(/members/{id}) -> 계층 구조상 상위를 컬렉션으로 보고 복수단어 사용을 권장한다. (member->members)

### 리소스와 행위를 분리
1. 가장 중요한 것은 리소스를 식별하는 것 -> URI는 리소스만 식별한다. -> 리소스(명사)와 해당 리소스를 대상으로 하는 행위(동사)를 분리

# HTTP 메서드 - GET, POST
1. 주요 HTTP 메서드로는 GET, POST, PUT, PATCH, DELETE가 있다.
2. 기타 메서드로는 HEAD, OPTIONS, CONNECT, TRACE가 있다.

### GET
1. 리소스 조회
2. 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)를 통해서 전달한다.
3. 메시지 바디를 사용해서 데이터를 전달할 수 있지만 지원하지 않는 곳이 많아서 권장하진 않는다. 

### POST
1. 요청 데이터 처리  -> 메시지 바디를 통해 서버로 요청 데이터 전달
2. 서버는 요청 데이터를 처리 -> 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다.
3. 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용한다.

# HTTP 메서드 - PUT, PATCH, DELETE

### PUT
1. 리소스를 대체(있으면 대체, 없으면 생성) -> 클라이언트가 리소스를 식별하여 위치(/members/100)를 알고 URI를 지정한다. -> POST와는 다르게 리소스의 식별한다.

### PATCH
1. 리소스를 부분 변경한다. -> 간혹 지원하지 않는 서버가 있는데, 그땐 POST를 쓰자.

### DELETE
1. 리소스를 제거한다.

# HTTP 메서드의 속성

### Safe(안전)
1. 호출해도 리소스를 변경하지 않는다는 뜻이다. ( GET, HEAD 같은 것들 )
2. 안전은 해당 리소스만 고려한다.

### Idempotent(멱등)
1. f(f(fx)) = f(x) -> 한 번 호출하든 두 번 호출하든 100번 하든 결과가 똑같은 것을 뜻한다. ( GET, PUT, DELETE )
2. 자동 복구 메커니즘으로 활용 -> 서버가 TIMEOUT 등으로 정상 응답을 못주었을 때, 클라이언트가 같은 요청을 다시 해도 되는가?를 판단하는 기준이 된다.
3. 멱등은 외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지 않는다.

### Cacheable(캐시가능)
1. 응답 결과 리소스를 캐시해서 사용하는 것
2. GET, HEAD, POST, PATCH 가능 -> 실제로는 GET, HEAD 정도로만 사용한다. -> POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않다.