## 당장 좋은 것만 선택하는 그리디 p.86

1. 그리디 알고리즘은 번역하면 탐욕법으로 소개된다. 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미한다. 매 순간 가장 좋아 보이는 것을 선택하며, 현재의 선택이 나중에 미칠 영향은 고려하지 않는다.
   <br><br>
2. 그리디 알고리즘은 기준에 따라 좋은 것을 선택하는 알고리즘이므로 문제에서 '가장 큰 순서대로', '가장 작은 순서대로'와 같은 기준을 알게 모르게 제시해준다. 대체로 이 기준은 정렬 알고리즘을 사용했을 때 만족시킬 수 있으므로 정렬 알고리즘과 자주 짝을 이뤄 출제된다.

### [거스름돈 p.87](https://github.com/Nnagman/TIL/blob/main/algorithm/Books/src/thisIsCodingTest/part2/greedy/Change.java)
1. 거스름돈이 발생했을 때, 가장 최소의 동전으로 거슬러 주는 문제다. 동전은 500원 100원 50원 10원으로 있고 거스름돈 N은 항상 10의 배수다.
   <br><br>
2. 이 문제는 가장 큰 순서대로 해결하면 된다. 거스름돈 N을 가장 큰 값을 가진 동전인 500원 부터 풀어나가면 된다. N을 동전 크기만큼 나눈 값을 저장하고 다음 동전을 계산하기 위해 N은 동전 크기만큼 나눈 뒤 나머지값을 가진다. 이것을 500원 100원 50원 10원 순으로 반복하면 정답이 나온다.

### 그리디 알고리즘의 정당성 p.90
1. 대부분의 문제는 그리디 알고리즘을 이용했을 때 '최적의 해'를 찾을 수 없을 가능성이 높다. 하지만 위의 거스름돈 문제를 그리디 알고리즘으로 풀 수 있었던 이유는 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문이다.
   <br><br>
2. 대부분의 그리디 알고리즘 문제에는 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 답을 도출할 수 있다.

### [큰 수의 법칙 p.92](https://github.com/Nnagman/TIL/blob/main/algorithm/Books/src/thisIsCodingTest/part2/greedy/LawOfBigNumber.java)
1. N개의 숫자들을 M번 만큼 더 했을 때 나올 수 있는 가장 큰 수를 구하는 문제다. 여기서 조건이 하나 주어진다. 연속된 숫자가 K번 만큼만 나올 수 있다는 것이다. 예를 들어 K가 3이고 6이 3번 연속적으로 더해졌다면 다른 숫자를 한번 더 한 뒤, 6을 더 할 수 있다.
   <br><br>
2. 주어진 수들에서 가장 큰 수를 골라 더하면 되는 문제여서 그리디 알고리즘으로 충분히 풀 수 있는 문제다. 단순히 반복문을 돌려가며 주어진 수들 중에서 가장 큰 수와 두번째로 가장 큰 수를 번갈아 가며 더하면 되지만 더 좋은 방법이 있다.
   <br><br>
3. 가장 큰 수를 K번 더한 뒤 두번째로 가장 큰 수를 한번 더해야 하는데, 이렇게 한번 반복하면 K+1이다. 결국 K+1을 반복하면 정답을 구할 수 있다. M을 K+1만큼 나눈 값 그리고 나머지 값을 활용하면 가장 큰 수를 얼마나 더해야 하는지 알 수 있으며( M/(K+1)*K ) M을 해당 값 만큼 뺀다면 ( M-M/(K+1)*K ) 두번째로 가장 큰 수를 얼마나 더해야 하는지 알 수 있다. 이 두 결과를 더 하면 정답이다.

### [숫자 카드 게임 p.96](https://github.com/Nnagman/TIL/blob/main/algorithm/Books/src/thisIsCodingTest/part2/greedy/NumberCardGame.java)
1. 카드들은 N행xM열 만큼 주어진다. 룰은 행을 선택하고 카드를 뽑는데 해당 행에서 가장 낮은 숫자를 가진 카드를 뽑아야 한다. 하지만 정답은 가장 큰 숫자를 가진 카드를 뽑아야한다.
   <br><br>
2. 문제를 해결하기 위해선 각 행들의 카드 값을 받으며 가장 낮은 숫자를 저장한 뒤, 다른 행들의 가장 낮은 카드 값들과 비교하여 그 중에서 가장 큰 카드 값을 뽑으면 된다.

### [1이 될 때까지 p.99](https://github.com/Nnagman/TIL/blob/main/algorithm/Books/src/thisIsCodingTest/part2/greedy/UntilReachOne.java)
1. N을 K만큼 나누거나 1을 빼는 과정을 얼마나 수행해야 1이 되는지 확인 하는 문제다.
   <br><br>
2. 먼저 K만큼 나누어 지기 위해서 N을 K의 배수가 될 때까지 빼기 연산을 수행한 뒤, 나누는 과정을 반복한다. 그러다가 N이 K보다 작아지면 1이 될 때까지 빼기 연산을 수행한다. 이 과정을 몇번 반복했는지가 정답이다.

