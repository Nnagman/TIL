## 기준에 따라 데이터를 정렬 p.156
1. 정렬이란 데이터를 특정한 기준에 따라서 순서대로 나열하는 것을 말한다.
   <br><br>
2. 정렬 알고리즘으로 데이터를 정렬하면 이진 탐색이 가능해진다. 정렬은 이진 탐색(Binary Search)의 전처리 과정이기도 하다.

### 선택 정렬 p.157
1. 선택 정렬은 가장 작은 것을 선택하는 것으로 데이터 중 가장 작은 것을 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 다음 순서의 데이터와 바꾸는 과정이다.
   <br><br>
2. 선택 정렬은 N - 1번 ㅋ만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 한다. 또 한, 매번 가장 작은 수를 찾기 위해서 비교 연산이 필요하다. 연산 횟수는 N + (N -1) + (N - 2) + ... + 2로 볼 수 있다. 근사치로 N X (N + 1) / 2 번의 연산을 수행한다고 가정하면 (N² + N) / 2로 표현할 수 있는데, 빅오 표기법으로 O(N²)로 표현할 수 있다. 

### 삽입 정렬 p.161
1. 삽입 정렬은  데이터를 적절한 위치에 삽입한다. 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다.
   <br><br>
2. N번째 데이터를 정렬해야 한다면 이미 정렬된 1 ~ N-1번째 데이터와 비교하여 N번째 데이터보다 큰 데이터 중 가장 작은 데이터의 왼쪽으로 삽입(만약 N번째 데이터가 가장 작다면 제일 왼쪽)된다.
   <br><br>
3. 삽입 정렬의 경우 시간 복잡도는 O(N²)이다. 하지만 데이터가 거의 정렬되어 있는 상황이라면 O(N)의 시간 복잡도를 가질 수 있다.

### 퀵 정렬 p.164
1. 퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다. 퀵 정렬에 사용되는 피벗은 큰 숫자와 작은 수자를 교환할 때, 교환하기 위한 기준이다. 퀵 정렬을 수행하기 전에 피벗을 어떻게 설정할 것인지 미리 명시해야 한다.
   <br><br>
2. 피벗을 설정하고 리스트를 분할하는 방법에 따라 여러 가지 방식으로 퀵 정렬을 구분하는데, 여기선 리스트에서 첫 번째 데이터를 피벗으로 정하는 호어 분할(Hoare Partition)방식을 기준으로 한다.
   <br><br>
3. 피벗 정렬을 시작하면 첫번째 데이터를 제외한 리스트에서 첫번째 데이터가 기준으로 기준보다 큰 데이터 중 가장 왼쪽의 데이터, 기준보다 작은 데이터 중 가장 오른쪽의 데이터를 기준으로 한다. 기준보다 큰 데이터를 왼쪽에서 오른쪽으로 차례대로 확인하고 기준보다 작은 데이터를 오른쪽에서 왼쪽으로 차례대로 확인한다. 그리고 한칸씩 확인하고 확인 후에는 왼쪽과 오른쪽 데이터의 위치를 서로 교환한다. 만약 큰 데이터와 작은 데이터의 위치가 서로 엇갈린다면 작은 데이터를 기준 데이터와 교환 후 기준을 따라 왼쪽과 오른쪽을 나누어(partition) 다시 정렬한다.
   <br><br>
4. 퀵 정렬의 평균 시간 복잡도는 O(NlogN)이다.  하지만 최악의 경우로 이미 데이터가 정렬되어 있다면 O(N²)이다. 퀵 정렬은 데이터가 무작위로 입력되는 경우 빠르게 동작할 확률이 높다.

### 계수 정렬 p.171
1. 계수 정렬은 데이터의 크기가 제한되어 정수 형태로 표현할 수 있는 특정한 조건이 부합할 때만 사용할 수 있는 매우 빠른 정렬 알고리즘이다. 일반적으로 가장 큰 데이터와 가장 작은 데이터 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있다.
   <br><br>
2. 이런 특징을 가지는 이유는 계수 정렬을 사용할 때 모든 범위를 담을 수 있는 크기의 리스트(배열)를 선언해야 하기 때문이다. 만약 가장 작은 데이터와 가장 큰 데이터의 차이가 1,000,000이라면 총 1,000,001개의 데이터가 들어갈 수 있는 리스트를 초기화 해야 한다.
   <br><br>
3. 계수 정렬은 선택, 삽입, 퀵 정렬처럼 직접 데이터의 값을 비교한 뒤 위치를 변경하는 비교 기반 정렬 알고리즘이 아니다. 일반적으로 별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담는 특징이 있다.
   <br><br>
4. 만약 0~9 까지의 크기를 가지는 데이터들이 주어진다면 0~9까지의 리스트를 0으로 초기화 한다. 정렬해야 하는 데이터들을 데이터 크기에 해당하는 인덱스에 값을 1씩 증감시킨다. 마지막 데이터까지 확인 했다면 리스트의 인덱스 0부터 시작하여 해당 인덱스의 값이 0이 될때까지 1씩 감소시키며 출력한다. 출력된 값은 정렬된 값이다.
   <br><br>
5. 계수 정렬의 시간 복잡도는 O(N+K)로 N은 데이터의 개수 K는 데이터 중 최대값의 크기다. K는 리스트의 각 인덱스에 대항하는 값들을 확인할 때 최소값에서 부터 최대값까지 확인하는 작업이다. 하지만 0과 999,999만 존재한다면 리스트의 크기가 100만 개가 되도록 선언해야 한다. 이럴 경우 데이터 2개를 확인하기 위해 100만개의 공간을 사용해야 하는 비효율을 초래할 수 있다. 데이터의 특성을 파악하기 어렵다면 퀵 정렬을 사용하는 것이 유리하다.

