##컴퓨터는 비트를 어떻게 기억하는가 p.135
조합 논리는 입력에 의해서만 출력이 기억된다. 하지만 조합 논리만으로는 컴퓨터를 만들 수는 없다. 흐름의 일부분을 뗴어내서 해둘려면 순차 논리(sequential logic)이 필요하다. 사람들은 시간의 흐름을 직관적으로 알지만 컴퓨터는 아니다. 디지털 회로에서 시간을 어떻게든 만들어야 한다. 순차 논리는 입력의 현재 상태와 과거 상태를 함께 고려하기 때문에 가능하다.

### 시간 표현과 상태 기억 p.136
1. 우린 주기(periodic) 함수를 사용해 시간을 측정할 수 있다. 주기적 함수는 지구의 자전, 지구가 한 바퀴를 다 돌면 하루라고 부르는 것 등이다. 컴퓨터의 경우 전자공학을 사용하기 때문에 주기적인 전기 신호가 필요하다.
   <br/><br/>
2. 되먹임(feedback)은 인버터의 출력을 입력에 연결하는 것이다. 이렇게 하면 0과 1 사이를 진동한다(oscillate). 진동하는 속도는 전파 지연에 따라 결정되고 온도에 따라 달라진다. 좀 더 안정적인 주파수로 진동하는 발진자(oscillator)가 필요하다.
   <br/><br/>
3. 전극(electrode,전선)을 크리스털(crystal)을 연결하고 압축하면 전기를 만들어낸다. 그리고 전극에 전기를 가하면 크리스털이 구부러진다. 이런 현상을 피에조 전기(piezoelectric, 압전) 효과라 부른다. 이 효과는 음성 진동을 잡아낼 수 있어서 마이크를 만들 때 쓸 수 있다.
   <br/><br/>
4. 크리스털 발진자는 전자적인 단극쌍투 스위치를 사용해 크리스털에 전기를 가해서 다시 전기를 얻어낸다. 입력한 전기로부터 크리스털이 전기를 다시 만들어내는 시간은 예측이 가능하며 매우 정확하다.
   <br/><br/>
5. 발진자는 클록(clock, 시간을 셀 수 있게 해주는 신호)을 제공한다. 클록을 활용하면 전파 지연 처럼 결과가 최악의 겨우를 가정해 가산기의 지연 시간을 기다릴 수 있다. 클록은 회로의 페이스(pace)를 결정한다. 회로의 최대 클록 속도나 가장 빠른 템포(tempo)는 회로의 전파 지연 시간에 의해 결정된다.
   <br/><br/>
6. 래치(latch)는 OR 게이트의 출력을 입력에 묶는 방식의 되먹임을 사용하여 1비트의 정보를 기억할 수 있다. set, reset, out을 활용하여 과거와 현재를 기억할 수 있다.
   <br/><br/>
7. 플립플롭(flip-flop)은 데이터 변경으로 인해 잘못된 결과가 생길 수 있는 가능성을 최소화 했다. 논리 수준이 특정 값에 머무는 동안 데이터를 잡아내지 않고 논리 수준이 한 수준에서 다른 수준으로 전이되는 중간에 데이터를 잡아 내는 것이다.
   <br/><br/>
8. 카운터(counter)는 플립플롭을 응용하여 1, 2, 3 순서대로 수를 세는 회로다.
   <br/><br/>
9. 레지스터(register)는 클록을 공유하는 여러 D 플립플롭을 한 패키지에 넣은 것이다. 가산기 회로로 덧셈한 결과를 레지스터에 저장할 수도 있다.

### 메모리 조직과 주소 지정 p.136
1. 비트를 하나 기억할 때 플립플롭이 유용하고 레지스터를 사용하면 여러 비트를 쉽게 저장할 수 있다. 더 많은 정보를 저장해야한다면 어떻게 해야 할까.