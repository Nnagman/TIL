## 컴퓨터 내부의 언어 체계 p.52

### 언어란 무엇인가 p.52
1. 모든 언어의 뜻은 기호의 집합으로 인코딩된다. 그리고 제대로 작동하려면 의사소통하는 당사자들이 모두 같은 문맥(Context)을 공유해서
같은 기호에 같은 뜻을 부여할 수 있어야 한다.

### 드모르간 법칙 p.56
1. 드모르간 법칙에선 a AND b 은 NOT(NOT a OR NOT b) 와 같다.
   <br/><br/>
2. 이 말은 NOT을 충분히 사용하면 AND 연산을 OR 연산으로 대신할 수 있다. ( 반대로 OR을 AND로 대신할 수 있다. )
   <br/><br/>
3. 긍정적인 논리(positive logic)에 더해 부정적인 논리(negative logic)를 기술하는 명제를 사용할 때 드모르간의 법칙을 사용할 수 있다.
   <br/><br/>
4. (춥다 OR 비가 온다)를 (NOT 춥다 AND NOT 비가 온다)와 같이 긍정적인 논리를 부정적인 논리로 변환한다. 만약 드모르간 법칙이 없었다면 ( NOT NOT 춥다 OR NOT NOT 비가 온다 )로 OR을 사용해야 했을 것이다.

### 2진수 덧셈 p.61
1. 2개의 숫자를 더할 때 가능한 경우의 수가 10진수 에서는 백 가지이나 2진수에서는 네 가지밖에 안 되기 때문에, 실제로는 2진수 덧셈이 좀 더 쉽다.
   <br/><br/>
2. 001 + 101을 하려면 가장 오른쪽 LSB부터 더하기 시작한다. 그리고 더하기 연산을 할 땐 AND와 XOR을 사용한다. 예를 들어 LSB에서 연산은 1 AND 1 -> 1 0 <- 1 XOR 1 와 같이 연산을 수행한다.
   <br/><br/>
3. 덧셈 결과가 우리가 사용할 비트의 개수로 표현할 수 있는 범위를 벗어나면 오버플로가 발생한다. 오버플로란 MSB에서 올림이 발생했다는 뜻이다.
   <br/><br/>
4. 컴퓨터에는 조컨 코드(또는 상태 코드) 레지스터(condition code register)라는 것이 있어서 몇 가지 이상한 정보를 담아둔다. 이런 정보 중에는 오버플로 비트가 있고, 이 비트에는 MSB에서 발생한 올림값이 들어간다. 이 비트값을 보면 오버플로가 발생했는지 알 수 있다. MSB에서 위쪽에서 1을 빌려오는 경우를 언더플로라고 부른다. 이에 해당하는 조건 코드도 컴퓨터에 들어 있다.

### 부호와 크기 p.63
1. 음수와 양수를 구별하기 위해 흔히 부호를 사용한다. 우리들은 가장 왼쪽 비트(MSB)를 부호에 사용하기로 결정했다. 이런 방법을 부호와 크기 표현법이라 한다. 이 방법은 두 가지 이유로 널리 쓰이지 못하고 있다. 첫째, 비트들을 구성하려면 비용이 드는데 0을 표현하는 방법이 두 가지라서 비용이 낭비된다. 둘째, 부호와 크기 표현법을 사용하려면 XOR과 AND를 통한 덧셈 계산을 사용할 수가 없다.

### 1의 보수 p.64
1. 음수를 표현하기 위해 양수의 모든 비트를 뒤집는 방법을 1의 보수 표현법이라 한다. 0111(7)을 1의 보수 표현법으로 음수로 변환하면 1000(-7)이 된다.
   <br/><br/>
2. 이 표현법도 0을 두 가지 방식으로 표현한다는 문제가 여전히 존재한다. 게다가 1의 보수에서도 덧셈을 쉽게 할 수 없다. 이 문제를 해결하려면 순환 올림이 필요하다.
   <br/><br/>
3. 순환 올림은 MSB에서 올림이 발생한 경우 LSB로 올림을 전달한다. 0010(+2) + 1110(-1)은 오버플로로 0000이 되어야 하지만 순환 올림으로 0001이 된다.
   <br/><br/>
4. 하지만 순환 올림을 처리하기 위한 하드웨어를 추가해야 하기 때문에 좋은 해법은 아니다.

### 2의 보수 p.66
1. 특별한 하드웨어 추가없이 XOR와 AND만을 사용하는 방법은 2의 보수 표현법이다.
   <br/><br/>
2. 0001(+1)에 덧셈을 했을 때 0이 나오는 비트 패턴을 -1이라 불러보자. 4비트 수의 경우에선 1111(-1)이다. 이런 표현법을 2의 보수 표현법이라 한다.
   <br/><br/>
3. 이 표현법에선 MSB 올림이 발생하면 해당 값을 버린다.

### 고정소수점 표현법 p.68
1. 고정소수점 표현은 2진 소수점의 위치를 임의로 정하는 방법이다. 만약 4비트의 공간이 있다면 2비트는 소수점의 왼쪽, 2비트는 오른쪽을 표현하는데 사용된다. 만약 1010이라면 2.5로, 1011이라면 2.75로 표현된다.
   <br/><br/>
2. 고정소수점 표현은 값이 너무 커지게 되면 그만큼 차지하는 공간에 늘어나는 문제점이 있다.

### 부동수소수점 표현법 p.69
1. 부동소수점 표현법은 소수점이 왼쪽이 한 자리뿐인 소수(가수)에 10을  몇 번(지수) 거듭제곱한 값을 곱하는 방식으로 소수를 표현하는 방식이다. 0.0012 대신 1.2*10^-3 으로 표현한다.
   <br/><br/>
2. 2진수에서 부동소수점 표현법은 문제점이 존재한다. 4비트로 표현한다 했을 때, 0을 표현하는 방법이 여러 가지다. ( 0.000(0\*2^0), 0.001(0\*2^1), 0.010(0\*2^2), 0.011(0\*2^3) ) 그리고 비트 패턴이 가능한 모든 수를 표현하지 못한다. 0.100 + 0.100 = 1.000 와 같이 0.5 끼리 더하여 1을 만들 수 있지만 6.5를 표현할 방법은 없다. ( 1.001(1\*2^1,2) + 1.010(1\*2^2,4) = 1.011(1\*2^3,8) 2진수 부동소수점에서 2+4는 6이 아닌 8이다. 이런 부정확한 계산을 어떻게 추척하고 개선할지 분석하는 수치 해석이란 수학 분야가 있다. )

### IEEE 부동소수점 표준 p.69
1. 가수(mantissa)에 진법의 수를 지수(exponent)만큼 곱하는 방법이 부동소수점 표현법이다. 이 방법은 현재까지도 널리 쓰이고 있다.
   <br/><br/>
2. IEEE754 표준에선 기존 부동소수점 표현법의 한계를 뛰어넘기 위해서 몇 가지 트릭을 썼다. 그 중 첫 번째는 가수와 지수의 위치를 바꿔 맨 앞(왼쪽)에 0이 없게 만드는 것이다. 두 번째는 가수의 맨 왼쪽 비트가 항상 1( 소수점 왼쪽이 1만 나오도록 정규화를 하면 항상 1이 된다. )이니깐 맨왼쪽을 1이라 가정하면 1비트를 더 쓸 수 있다.
   <br/><br/>
3. 가수에는 부호 비트가 있지만 지수에는 부호 비트가 없다. IEEE 754를 설계한 사람은 0이거나 1인 경우에 특별한 의미를 갖게 하고, 실제 지수 값은 나머지 비트 패턴에 넣고 싶었다. 그래서 편향된(biased) 지숫값을 사용했다. 지수가 8비트인 기본 정밀도의 경우 편향값은 127로 127(1111 1111)이 지수 0을 표현하고 0000 0001은 -126 그리고 1111 1110은 +127을 표현한다. 그래서 2진수의 지수부를 IEEE 부동소수점 표준으로 표기하려면 1000 0000(+128)이라는 Bias 상수를 더한 뒤 표기해야 한다.

### 2진 코드화한 10진 시스템 p.73
1. 2진 코드화한 10진수(BCD, binary-coded decimal)은 4비트를 사용해 10진수 숫자 중 하나를 표현한다. 예를 들어 12를 표현하면 0001 0010으로 표기한다.
   <br/><br/>
2. 하지만 이 방법은 4비트로 표현할 수 있는 16가지 방법 중 6가지(1111, 1110, 1101, 1100, 1011, 0000)를 버리는 방법이라 효율적이지 않다.

### 16진 표현법 p.74
1. 8진 표현법(001와 같이 3bit 표현방법)이 사용되기는 하지만 요즘은 16진 표현법이 쓰이고 있다. 그 이유는 요즘 컴퓨터는 대부분 8비트의 배수를 사용해 만들어지기 때문이다. ( 16진수는 비트로 표현하면 4의 배수라 나누면 딱 맞아 떨어진다. ) 

### 프로그래밍 언어의 진법 표기법 p.75
1. 0으로 시작하는 숫자는 8진 숫자다. 017은 8진수며 10진수로 표기하면 15다.
   <br/><br/>
2. 1부터 9사이의 숫자로 시작하는 숫자는 10진 숫자다.
   <br/><br/>
3. 0x가 접두사인 숫자는 16진수다. 0x12f는 16진수며 10진수로는 303이다.

### 비트 그룹의 이름 p.76
1. 비트의 묶음은 니블(nibble, 4bit), 바이트(byte, 8bit), 하프 워드(half word, 16bit), 워드(word, 32bit), 더블 워드(double word, 64bit)로 불린다.
   <br/><br/>
2. 워드는 각 컴퓨터가 설계상 자연스럽게 사용할 수 있는 비트 묶음 크기를 가리키는 말로 쓰인다. int라고 선언한 변수가 이런 자연스러운 크기의 2진수를 표현한다.
   <br/><br/>
3. 미터법에서 쓰이는 키로, 메가, 기가, 테라와 같은 용어를 빌려와 키로바이트, 메가바이트, 기가바이트, 테라바이트라 부르며 밑이 미터법의 10과는 다른 2를 밑으로 가지는 표현법을 만들었다. 하지만 이 의미가 미터법과 혼용되는 문제가 있어서 최근에는 kibi(KiB), mebi(MiB), gibi(GiB), tebi(TiB)와 같이 불리기도 한다.

### 유니코드 변환 형식 8비트 p.81
1. 예전엔 ASCII 코드로 영어와 특수문자를 표현할 수 있었다. 하지만 컴퓨터를 사용하는 언어권이 늘어나자 다른 언어들도 표현할 수 있어야 했다. 그렇게 나온게 바로 유니코드다. 하지만 유니코드는 16비트로 표현되고 있었고 아스키 코드(8비트)보단 2배가 길다. 이 유니코드를 8비트로 표현하기 위해 나온 방법이 바로 UTF-8(Unicode Transformation Format-8 bit)다.
   <br/><br/>
2. UTF-8은 아스키 코드에 해당하는 문자는 8비트로 저장하고 그렇지 않은 경우에는 인코딩하여 저장한다. UTF-8은 8비트 중에서 MSB 쪽에 있는 비트들이 시퀀스의 길이를 표현한다. 이는 덩어리의 맨 앞을 식별하기 쉽다.

### 문자를 사용한 수 표현 p.83
1. UTF-8은 문자(A)를 표현하는 비트들(0000 0000 1000 0000)로부터 나온 숫자들(0x0041)을 표현하는 숫자들(UTF-8로 인코딩한 값)을 표현하기 위해 숫자(UTF-8로 인코딩한 0x41)들을 사용한다.
   <br/><br/>
2. 이젠 문자를 사용해 수를 표현할 수 있다. 컴퓨터와 컴퓨터 사이의 통신이 시작된 시점부터 사람들은 더 많은 정보를 송수신하고 싶었다. 하지만 2진 데이터를 직접보내는 것은 쉬운게 아니다. 아스키 코드 중 상당수가 제어 문자로 되어 있었고 시스템에 따라 처리하는 방식이 다르고 7비트만 송수신 할 수 있었기 때문이다.

### 출력 가능하게 변경한 인코딩 p.83
1. 출력 가능하게 변경한 인코딩(QP,Quoted-Printable encoding)은 8비트 데이터를 7비트 데이터만 지원하는 통신 경로를 통해 송수신하기 위한 인코딩 방법이다.
   <br/><br/>
2. QP 인코딩은 전자우편 첨부를 처리하기 위해 만들어졌다. 이 인코딩을 사용하면 = 다음에 바이트의 각 니블을 표현하는 16진 숫자 2개를 추가해 8비트 값을 표현한다.
   <br/><br/>
3. 이 인코딩은 한 줄이 76자를 넘을 수 없어서 어떤 줄의 맨 뒤에 =를 붙여 가짜 줄바꿈(soft line break)를 한다.

### Base64 인코딩 p.84
1. QP는 1바이트를 표현하기 위해 3바이트를 사용하는 만큼 비효율적이다. 하지만 Base64 인코딩은 3바이트 데이터를 4문자로 표현한다.
   <br/><br/>
2. 3바이트 데이터의 24비트를 네 가지 6비트 덩어리로 나누고, 각 덩어리의 6비트값에 출력 가능한 문자를 할당해 표현한다.
   <br/><br/>
3. 하지만 원본 데이터의 길이가 3바이트의 배수가 아닐 겨우 패딩(Padding) 문자를 도입해 이런 문제를 해결한다. 2바이트가 남으면 끝에 =를 붙이고 1바이트 남으면 ==를 붙인다.

### URL 인코딩 p.85
1. URL 인코딩은 QP와는 다르게 = 대신 %를 사용한다. %26, %2F 같은 문자 시퀀스를 리터럴(literal)로 사용한다.
   <br/><br/>
2. 퍼센트 인코딩(percent-encoding)이라고도 불리는데, %뒤에 어떤 문자의 16진 표현을 덧붙이는 방식으로 문자를 인코딩한다.

### 색을 표현하는 방법 p.86
1. Computer Graphics는 전자 모눈종이에 해당하는 것에 색을 표현하는 점(blob)을 찍어서 그림을 그리는 과정이다. 이때 모눈의 각 격자에 찍는 점을 Picture Element(그림 원소), 줄여서 Pixel이라 부른다.
   <br/><br/>
2. 컴퓨터 모니터는 빨간색, 녹색, 파란색 광선을 섞어서 색을 만든다. 이런 표현법을 RGB Color Model이라 한다. 색은 정육면체의 컬러 큐브(Color Cube)로 표현 할 수 있으며 각 축은 주(Primary)색을 표현한다. 축과 멀어지면 (0과 가까워 지면) 해당 색을 끈다는 뜻이고 가까워지면 (1과 가까워 지면) 해당하는 주 색의 빛을 최대 밝기로 켠다. 모든 축이 0이라면 검정색, 1이라면 흰색을 표현한다. 컬러큐브는 파란색(blue, 0,0,1), 청록색(Cyan, 0,1,1), 녹색(Green, 0,1,0), 노란색(Yellow, 1,1,0), 빨간색(Red, 1,0,0), 자홍색(Magenta, 1,0,1). 검은색(Black, 0,0,0)으로 이루어져 있다.
   <br/><br/>
3. RGB와 같이 색을 더해서 표현하는 방식은 가산(additive) 색 시스템이라 부른다. 반대로 손으로 그림을 그린다면 아마 감산(subtractive) 색 시스템에 더 익숙할 것이다. 감산 색 시스템의 주 색은 청록색(Cyan), 자홍색(Magenta), 노란색(Yellow)이다.
   <br/><br/>
4. 현대 컴퓨터들은 색을 표현하는데 24비트를 사용하여 1천만에 가장 가까운 2의 제곱수에 해당하는 색을 표현할 수 있다. 이 비트는 세 가지 8비트 필드로 나뉘며, 각 필드는 세 가지 주요 색을 표현한다. 하지만 24비트에 해당하는 이름이 없었다. 그렇게 되면 컴퓨터는 24비트에 가장 가까운 표준크기인 32비트(워드)에 담아서 색을 표현할 때 마다 8비트를 낭비한다. 이 낭비되는 8비트는 투명도(Transparency)라는 요소로 사용되게 되었다. 투명도는 해당 색을 '투과해 볼 수 있는 정도'를 뜻한다. 투명도가 없다면 장밋빛 유리잔 같은 대상을 표현하지 못하고 오직 불투명(Opaque)한 색만 표현했을 것이다.

### 투명도 추가 p.88
1. 옛날 애니메이터들은 각 프레임을 부드럽게 전환하기 위해 투명도를 사용했다. 투명도가 있으면 여러가지 이미지를 하나로 합성(Compose) 할 수 있다. 그리고 영화계에서도 이런 투명도, 합성을 사용하여 색을 표현한 계산법인 합성 계산법(Compositing algebra)라는 식을 만들었다.
   <br/><br/>
2. 합성 계산법은 1부터 255까지(0~7비트)의 값을 α 값으로 사용했고 빨간색, 녹색, 파란색 값에 α를 곱한 값으로 저장했다. 그럼 0~7비트는 α, 8~31까진 파란색α, 녹색α, 빨간색α으로 표현된다. α이 1과 가까워지면 불투명하고 0과 가까워지면 투명한 것이다.
   <br/><br/>
3. 이미지 합성은 색값을 α로 곱하는 과정을 통해 이뤄진다. 그리고 α만큼 미리 곱한 값을 저장하기 때문에 α를 곱하는 계산을 반복할 필요가 없다.

### 색 인코딩 p.89
1. 웹 페이지는 주로 사람이 읽을 수 있는 UTF-8 문자의 시퀀스로 이뤄지는 텍스트를 표현하기 때문에 색을 표현하려면 텍스트를 사용하는 방법을 써야 한다.
   <br/><br/>
2. URL 인코딩과 비슷한 방법을 쓴다. #뒤에 16진 숫자를 추가하는 16진 트리플렛(hex triplet)으로 표현한다. #rrggbb로 rr은 red, gg는 green, bb는 blue를 뜻한다. 웹 페이지에서도 투명도를 나타내는 α를 사용할 수 있지만 간결한 형식으로 표현하는 방법은 없다.